Index: chess/src/AI/Board.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package AI;\r\n\r\nimport network.Client;\r\nimport quanco.*;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.awt.event.MouseAdapter;\r\nimport java.awt.event.MouseEvent;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport javax.swing.Timer;\r\nimport sounds.SoundPlayer;\r\n\r\npublic class Board extends JPanel {\r\n    private final int boardWidth = 9;  // Số cột\r\n    private final int boardHeight = 10; // Số hàng\r\n    private final int cellSize = 70;    // Kích thước của mỗi ô\r\n    private List<Piece> pieces;          // Danh sách các quân cờ\r\n    private Image boardImage;            // Hình ảnh bàn cờ\r\n    private Image backgroundImage;\r\n    private Piece selectedPiece;          // Quân cờ đang được chọn\r\n    private int mouseX, mouseY;          // Vị trí chuột khi kéo\r\n    private boolean isRedTurn = true;    // Biến xác định lượt\r\n    private Timer timer;                  // Bộ đếm thời gian\r\n    private int timeLeft = 60;            // Thời gian còn lại\r\n    private JLabel timerLabel;            // Nhãn hiển thị thời gian\r\n    private List<MovePair> moveHistoryPairs;\r\n    private Move lastRedMove = null;\r\n    private Move lastBlackMove = null;\r\n    private boolean isAIEnabled;\r\n    private Piece[][] board;\r\n    private boolean gameOver = false;\r\n    private Client client;\r\n\r\n\r\n    public Board(boolean isAIEnabled,String difficulty,Client client) {\r\n        this.client = client;\r\n        this.isAIEnabled = isAIEnabled;\r\n        board = new Piece[10][9];\r\n        setPreferredSize(new Dimension(boardWidth * cellSize, boardHeight * cellSize));\r\n        pieces = new ArrayList<>();\r\n        moveHistoryPairs = new ArrayList<>(); // Khởi tạo danh sách lịch sử nước đi\r\n\r\n        // Thêm quân Tướng Đỏ và Đen vào danh sách\r\n        pieces.add(new King(4, 9, true, pieces));  // Tướng Đỏ ở vị trí (4, 9)\r\n        pieces.add(new King(4, 0, false, pieces)); // Tướng Đen ở vị trí (4, 0)\r\n\r\n        // Thêm các quân cờ khác...\r\n        pieces.add(new chot(0, 6, true, pieces));\r\n        pieces.add(new chot(0, 3, false, pieces));\r\n        pieces.add(new chot(2, 6, true, pieces));\r\n        pieces.add(new chot(2, 3, false, pieces));\r\n        pieces.add(new chot(4, 6, true, pieces));\r\n        pieces.add(new chot(4, 3, false, pieces));\r\n        pieces.add(new chot(6, 6, true, pieces));\r\n        pieces.add(new chot(6, 3, false, pieces));\r\n        pieces.add(new chot(8, 6, true, pieces));\r\n        pieces.add(new chot(8, 3, false, pieces));\r\n\r\n        // Thêm quân xe, mã, tướng, si, pháo...\r\n        pieces.add(new xe(0, 9, true, pieces));\r\n        pieces.add(new xe(0, 0, false, pieces));\r\n        pieces.add(new xe(8, 9, true, pieces));\r\n        pieces.add(new xe(8, 0, false, pieces));\r\n        pieces.add(new ma(1, 9, true, pieces));\r\n        pieces.add(new ma(1, 0, false, pieces));\r\n        pieces.add(new ma(7, 9, true, pieces));\r\n        pieces.add(new ma(7, 0, false, pieces));\r\n        pieces.add(new tuong(2, 9, true, pieces));\r\n        pieces.add(new tuong(2, 0, false, pieces));\r\n        pieces.add(new tuong(6, 9, true, pieces));\r\n        pieces.add(new tuong(6, 0, false, pieces));\r\n        pieces.add(new si(3, 9, true, pieces));\r\n        pieces.add(new si(3, 0, false, pieces));\r\n        pieces.add(new si(5, 9, true, pieces));\r\n        pieces.add(new si(5, 0, false, pieces));\r\n        pieces.add(new phao(1, 7, true, pieces));\r\n        pieces.add(new phao(1, 2, false, pieces));\r\n        pieces.add(new phao(7, 7, true, pieces));\r\n        pieces.add(new phao(7, 2, false, pieces));\r\n\r\n        // Khởi tạo nhãn thời gian\r\n        timerLabel = new JLabel(\"Time left: \" + timeLeft);\r\n        timerLabel.setFont(new Font(\"Arial\", Font.BOLD, 16));\r\n        timerLabel.setForeground(Color.RED);\r\n        add(timerLabel, BorderLayout.NORTH); // Thêm nhãn vào JPanel\r\n\r\n        // Khởi động bộ đếm thời gian\r\n        startTimer();\r\n\r\n        // Thêm các sự kiện chuột\r\n        addMouseListener(new MouseAdapter() {\r\n            @Override\r\n            public void mousePressed(MouseEvent e) {\r\n                // Tính toán vị trí của chuột khi nhấn, bao gồm việc căn giữa bàn cờ\r\n                int x = (e.getX() - (getWidth() - boardWidth * cellSize) / 2) / cellSize;\r\n                int y = (e.getY() - (getHeight() - boardHeight * cellSize) / 2) / cellSize;\r\n\r\n                // Kiểm tra nếu chuột nhấn vào một ô hợp lệ trong bàn cờ (trong phạm vi 9x10)\r\n                if (x >= 0 && x < boardWidth && y >= 0 && y < boardHeight) {\r\n                    // Kiểm tra nếu quân cờ ở vị trí nhấn chuột và nếu đó là lượt của người chơi\r\n                    for (Piece piece : pieces) {\r\n                        if (piece.getX() == x && piece.getY() == y && piece.isRed() == isRedTurn) {\r\n                            selectedPiece = piece; // Lưu quân cờ được chọn\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Lưu vị trí chuột để dùng khi di chuyển quân\r\n                mouseX = e.getX();\r\n                mouseY = e.getY();\r\n                repaint(); // Vẽ lại bàn cờ\r\n            }\r\n\r\n\r\n            @Override\r\n            public void mouseReleased(MouseEvent e) {\r\n                if (selectedPiece != null) {\r\n                    // Tính toán vị trí ô mới khi thả chuột, bao gồm việc căn giữa bàn cờ\r\n                    int newX = (e.getX() - (getWidth() - boardWidth * cellSize) / 2) / cellSize;\r\n                    int newY = (e.getY() - (getHeight() - boardHeight * cellSize) / 2) / cellSize;\r\n\r\n                    if (isRedTurn) { // Nếu lượt là của người chơi đỏ\r\n                        // Kiểm tra xem di chuyển có hợp lệ không\r\n                        if (selectedPiece.isValidMove(newX, newY) && newY >= 0 && newY < boardHeight) {\r\n                            Piece targetPiece = getPieceAt(newX, newY); // Kiểm tra quân ở vị trí mới\r\n\r\n                            if (targetPiece == null || targetPiece.isRed() != selectedPiece.isRed()) {\r\n                                // Nếu không có quân cờ hoặc có quân địch\r\n                                if (targetPiece != null) {\r\n                                    pieces.remove(targetPiece); // Loại bỏ quân địch\r\n                                }\r\n\r\n                                // Lưu vị trí cũ để khôi phục nếu cần\r\n                                int originalX = selectedPiece.getX();\r\n                                int originalY = selectedPiece.getY();\r\n\r\n                                // Thực hiện di chuyển\r\n                                selectedPiece.setPosition(newX, newY);\r\n\r\n                                String moveData = \"MOVE \" + selectedPiece.getX() + \" \" + selectedPiece.getY() + \" \" + newX + \" \" + newY;\r\n                                client.sendMessage(moveData); // Giả sử `client` là đối tượng đang quản lý kết nối với server\r\n\r\n\r\n                                // Kiểm tra nếu quân cờ vẫn bị chiếu sau nước đi này\r\n\r\n\r\n                                if (isCheck(isRedTurn)) {\r\n                                    // Nếu nước đi không thoát khỏi chiếu, hoàn tác di chuyển\r\n                                    selectedPiece.setPosition(originalX, originalY);\r\n                                    if (targetPiece != null) {\r\n                                        pieces.add(targetPiece); // Khôi phục quân cờ địch\r\n                                    }\r\n                                } else {\r\n                                    // Nước đi hợp lệ\r\n                                    Move move = new Move(selectedPiece, originalX, originalY, newX, newY, targetPiece);\r\n                                    if (isRedTurn) {\r\n                                        lastRedMove = move;\r\n                                    } else {\r\n                                        lastBlackMove = move;\r\n                                        if (lastRedMove != null) {\r\n                                            moveHistoryPairs.add(new MovePair(lastRedMove, lastBlackMove));\r\n\r\n                                            lastRedMove = null;\r\n                                            lastBlackMove = null;\r\n                                        }\r\n                                    }\r\n\r\n                                    // Kiểm tra chiếu sau khi di chuyển\r\n                                    if (isCheck(!isRedTurn)) {\r\n                                        JOptionPane.showMessageDialog(Board.this,\r\n                                                (isRedTurn ? \"Đen\" : \"Đỏ\") + \" bị chiếu!\", \"Thông báo\", JOptionPane.WARNING_MESSAGE);\r\n                                    }\r\n\r\n                                    // Kiểm tra chiếu tướng\r\n                                    if (isCheckmate(!isRedTurn)) {\r\n                                        JOptionPane.showMessageDialog(Board.this,\r\n                                                (isRedTurn ? \"Đen\" : \"Đỏ\") + \" đã thua!\", \"Game Over\", JOptionPane.WARNING_MESSAGE);\r\n                                        System.exit(0); // Kết thúc trò chơi\r\n                                    }\r\n\r\n                                    isRedTurn = false; // Đổi lượt cho AI\r\n                                    timeLeft = 60; // Reset thời gian\r\n                                    if (isAIEnabled) {\r\n                                        AIPlayer aiPlayer = new AIPlayer();\r\n                                        aiPlayer.setDifficultyLevel(difficulty);\r\n                                        long timeLimit = 1000;  // 1 second\r\n                                        Move aiMove = aiPlayer.getBestMove(Board.this, isRedTurn, timeLimit);\r\n\r\n                                        if (aiMove != null) {\r\n                                            makeMove(aiMove); // Thực hiện nước đi của AI\r\n                                            lastBlackMove = aiMove; // Lưu lại nước đi của AI\r\n\r\n                                            // Thêm vào lịch sử nước đi nếu cả người và AI đều có nước đi\r\n                                            if (lastRedMove != null) {\r\n                                                moveHistoryPairs.add(new MovePair(lastRedMove, lastBlackMove));\r\n                                                lastRedMove = null;\r\n                                                lastBlackMove = null;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    // Đổi lượt trở lại cho người chơi\r\n                                    isRedTurn = true;\r\n\r\n                                    // Vẽ lại bàn cờ sau khi di chuyển\r\n                                    repaint(); // Gọi repaint để cập nhật bàn cờ\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Phát âm thanh khi di chuyển quân cờ\r\n                    SoundPlayer soundPlayer = new SoundPlayer();\r\n                    if (selectedPiece.isRed()) {\r\n                        soundPlayer.playSound(\"/sounds/move.wav\"); // Âm thanh cho quân đỏ\r\n                    } else {\r\n                        soundPlayer.playSound(\"/sounds/move2.wav\"); // Âm thanh cho quân đen\r\n                    }\r\n\r\n                    selectedPiece = null; // Đặt lại quân cờ được chọn\r\n                    repaint(); // Vẽ lại bảng cờ\r\n                }\r\n            }\r\n\r\n\r\n        });\r\n\r\n        addMouseMotionListener(new MouseAdapter() {\r\n            @Override\r\n            public void mouseDragged(MouseEvent e) {\r\n                if (selectedPiece != null) {\r\n                    mouseX = e.getX();\r\n                    mouseY = e.getY();\r\n                    repaint(); // Vẽ lại để quân cờ di chuyển theo chuột\r\n                }\r\n            }\r\n        });\r\n\r\n        // Tải hình ảnh bàn cờ\r\n        try {\r\n            boardImage = ImageIO.read(getClass().getResourceAsStream(\"/img/board.gif\"));\r\n            backgroundImage = ImageIO.read(getClass().getResourceAsStream(\"/img/HinhNen/backgroundboard.jpg\"));// Sử dụng \"/\" để chỉ đường dẫn từ thư mục gốc\r\n            if (boardImage == null) {\r\n                System.out.println(\"Hình ảnh bàn cờ không thể tải!\");\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n    public List<Piece> getAllPieces() {\r\n        List<Piece> pieces = new ArrayList<>();\r\n        for (int row = 0; row < board.length; row++) {\r\n            for (int col = 0; col < board[row].length; col++) {\r\n                if (board[row][col] != null) {\r\n                    pieces.add(board[row][col]);\r\n                }\r\n            }\r\n        }\r\n        return pieces;\r\n    }\r\n\r\n    // Phương thức hoàn tác nước đi cuối cùng\r\n    public boolean undoLastMovePair() {\r\n        if (moveHistoryPairs.isEmpty()) {\r\n            return false;\r\n        }\r\n\r\n        MovePair lastPair = moveHistoryPairs.remove(moveHistoryPairs.size() - 1);\r\n\r\n        if (lastPair.getRedMove() != null) {\r\n            lastPair.getRedMove().getPiece().setPosition(lastPair.getRedMove().getOldX(), lastPair.getRedMove().getOldY());\r\n            if (lastPair.getRedMove().getCapturedPiece() != null) {\r\n                pieces.add(lastPair.getRedMove().getCapturedPiece());\r\n            }\r\n        }\r\n\r\n        if (lastPair.getBlackMove() != null) {\r\n            lastPair.getBlackMove().getPiece().setPosition(lastPair.getBlackMove().getOldX(), lastPair.getBlackMove().getOldY());\r\n            if (lastPair.getBlackMove().getCapturedPiece() != null) {\r\n                pieces.add(lastPair.getBlackMove().getCapturedPiece());\r\n            }\r\n        }\r\n\r\n        isRedTurn = !isRedTurn;\r\n        repaint();\r\n        return true;\r\n    }\r\n\r\n    public List<Move> getAllPossibleMoves(boolean isRed) {\r\n        List<Move> moves = new ArrayList<>();\r\n        for (Piece piece : pieces) {\r\n            if (piece.isRed() == isRed) {\r\n                for (int[] validMove : piece.getValidMoves()) {\r\n                    moves.add(new Move(piece, piece.getX(), piece.getY(), validMove[0], validMove[1], getPieceAt(validMove[0], validMove[1])));\r\n                }\r\n            }\r\n        }\r\n        return moves;\r\n    }\r\n\r\n    public void makeMove(Move move) {\r\n        Piece targetPiece = getPieceAt(move.getNewX(), move.getNewY());\r\n        if (targetPiece != null) {\r\n            pieces.remove(targetPiece); // Xóa quân cờ bị ăn\r\n        }\r\n        Piece movedPiece = move.getPiece(); // Lấy quân cờ cần di chuyển\r\n        if (movedPiece != null) {\r\n            movedPiece.setPosition(move.getNewX(), move.getNewY()); // Di chuyển quân cờ\r\n        } else {\r\n            System.out.println(\"Quân cờ không tồn tại.\");\r\n        }\r\n        repaint(); // Vẽ lại bàn cờ\r\n    }\r\n    private void startTimer() {\r\n        timer = new Timer(1000, e -> {\r\n            if (timeLeft > 0) {\r\n                timeLeft--;\r\n                timerLabel.setText(\"Time left: \" + timeLeft);\r\n            } else {\r\n                // Nếu thời gian hết, thông báo và kết thúc trò chơi\r\n                JOptionPane.showMessageDialog(this, (isRedTurn ? \"Đỏ\" : \"Đen\") + \" đã hết thời gian!\", \"Game Over\", JOptionPane.WARNING_MESSAGE);\r\n                System.exit(0); // Thoát trò chơi\r\n            }\r\n        });\r\n        timer.start();\r\n    }\r\n\r\n    // Phương thức vẽ bàn cờ\r\n    @Override\r\n    protected void paintComponent(Graphics g) {\r\n        super.paintComponent(g);\r\n\r\n        // Tính toán vị trí vẽ bàn cờ sao cho nó nằm chính giữa màn hình\r\n        int x = (getWidth() - boardWidth * cellSize) / 2;\r\n        int y = (getHeight() - boardHeight * cellSize) / 2;\r\n\r\n        // Vẽ hình nền của bàn cờ\r\n        if (backgroundImage != null) {\r\n            g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), null); // Vẽ hình nền nền cho bàn cờ\r\n        }\r\n\r\n        // Vẽ hình ảnh bàn cờ lên chính giữa màn hình\r\n        if (boardImage != null) {\r\n            g.drawImage(boardImage, x, y, boardWidth * cellSize, boardHeight * cellSize, null); // Vẽ bàn cờ vào vị trí căn giữa\r\n        }\r\n\r\n        // Nếu có quân cờ được chọn, vẽ dấu chấm vàng và các nước đi hợp lệ\r\n        if (selectedPiece != null) {\r\n            // Vẽ các nước đi hợp lệ\r\n            List<int[]> validMoves = selectedPiece.getValidMoves();\r\n            g.setColor(new Color(0, 255, 0, 128)); // Màu xanh với độ trong suốt\r\n            for (int[] move : validMoves) {\r\n                int validX = move[0];\r\n                int validY = move[1];\r\n                g.fillRect(validX * cellSize + x + 10, validY * cellSize + y + 10, cellSize - 20, cellSize - 20); // Vẽ ô cho nước đi hợp lệ\r\n            }\r\n        }\r\n\r\n        // Vẽ các quân cờ lên chính giữa màn hình\r\n        for (Piece piece : pieces) {\r\n            piece.draw(g, cellSize, x, y); // Đảm bảo vẽ quân cờ vào vị trí chính xác với offset\r\n        }\r\n    }\r\n\r\n\r\n    Piece getPieceAt(int x, int y) {\r\n        for (Piece piece : pieces) {\r\n            if (piece.getX() == x && piece.getY() == y) {\r\n                return piece;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Hàm kiểm tra chiếu\r\n    private boolean isCheck(boolean isRed) {\r\n        Piece king = null;\r\n        for (Piece piece : pieces) {\r\n            if (piece instanceof King && piece.isRed() == isRed) {\r\n                king = piece;\r\n                break;\r\n            }\r\n        }\r\n        if (king == null) return true;\r\n\r\n        for (Piece piece : pieces) {\r\n            if (piece.isRed() != isRed && piece.isValidMove(king.getX(), king.getY())) {\r\n                return true; // Quân địch có thể ăn Tướng\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Hàm kiểm tra chiếu tướng\r\n    private boolean isCheckmate(boolean isRed) {\r\n        if (!isCheck(isRed)) return false;\r\n\r\n        for (Piece piece : pieces) {\r\n            if (piece.isRed() == isRed) {\r\n                for (int[] move : piece.getValidMoves()) {\r\n                    int originalX = piece.getX();\r\n                    int originalY = piece.getY();\r\n\r\n                    piece.setPosition(move[0], move[1]);\r\n\r\n                    if (!isCheck(isRed)) {\r\n                        piece.setPosition(originalX, originalY);\r\n                        return false;\r\n                    }\r\n                    piece.setPosition(originalX, originalY);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // Lớp Move để lưu trữ thông tin của mỗi nước đi\r\n\r\n\r\n    class MovePair {\r\n        private final Move redMove;\r\n        private final Move blackMove;\r\n\r\n        public MovePair(Move redMove, Move blackMove) {\r\n            this.redMove = redMove;\r\n            this.blackMove = blackMove;\r\n        }\r\n\r\n        public Move getRedMove() {\r\n            return redMove;\r\n        }\r\n\r\n        public Move getBlackMove() {\r\n            return blackMove;\r\n        }\r\n    }\r\n    public boolean isGameOver() {\r\n        // Kiểm tra nếu một trong hai tướng đã bị bắt\r\n        for (Piece piece : pieces) {\r\n            if (piece instanceof King && piece.isCaptured()) {\r\n                return true; // Trò chơi kết thúc vì một bên bị mất tướng\r\n            }\r\n        }\r\n        // Kiểm tra nếu không còn nước đi hợp lệ cho người chơi hiện tại\r\n\r\n        return false; // Trò chơi chưa kết thúc\r\n    }\r\n\r\n    public void undoMove(Move move) {\r\n        if (move != null) {\r\n            Piece movedPiece = move.getMovedPiece();\r\n            if (movedPiece != null) {\r\n                movedPiece.setPosition(move.getStartPosition());\r\n                if (move.getCapturedPiece() != null) {\r\n                    pieces.add(move.getCapturedPiece());\r\n                }\r\n                // Cập nhật lại các trạng thái khác nếu cần\r\n            } else {\r\n                System.out.println(\"movedPiece is null. Check the logic when creating Move.\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public List<Piece> getPieces() {\r\n        // Trả về danh sách các quân cờ hiện tại\r\n        return new ArrayList<>(pieces);\r\n    }\r\n    public List<Move> getAllValidMoves() {\r\n        List<Move> validMoves = new ArrayList<>();\r\n\r\n        for (Piece piece : pieces) {\r\n            if (!piece.isCaptured()) { // Kiểm tra xem quân cờ có đang trên bàn cờ hay không\r\n                List<Move> moves = piece.getValidMoves(this); // Giả sử Piece có phương thức getValidMoves\r\n                validMoves.addAll(moves);\r\n            }\r\n        }\r\n\r\n        return validMoves;\r\n    }\r\n    public void resetGame() {\r\n        pieces.clear();\r\n        moveHistoryPairs.clear();\r\n        lastRedMove = null;\r\n        lastBlackMove = null;\r\n        isRedTurn = true;\r\n        timeLeft = 60;\r\n\r\n        // Thêm lại các quân cờ vào bàn\r\n        pieces.add(new King(4, 9, true, pieces));  // Tướng Đỏ ở vị trí (4, 9)\r\n        pieces.add(new King(4, 0, false, pieces)); // Tướng Đen ở vị trí (4, 0)\r\n\r\n        // Thêm các quân cờ khác...\r\n        pieces.add(new chot(0, 6, true, pieces));\r\n        pieces.add(new chot(0, 3, false, pieces));\r\n        pieces.add(new chot(2, 6, true, pieces));\r\n        pieces.add(new chot(2, 3, false, pieces));\r\n        pieces.add(new chot(4, 6, true, pieces));\r\n        pieces.add(new chot(4, 3, false, pieces));\r\n        pieces.add(new chot(6, 6, true, pieces));\r\n        pieces.add(new chot(6, 3, false, pieces));\r\n        pieces.add(new chot(8, 6, true, pieces));\r\n        pieces.add(new chot(8, 3, false, pieces));\r\n\r\n        pieces.add(new xe(0, 9, true, pieces));\r\n        pieces.add(new xe(0, 0, false, pieces));\r\n        pieces.add(new xe(8, 9, true, pieces));\r\n        pieces.add(new xe(8, 0, false, pieces));\r\n        pieces.add(new ma(1, 9, true, pieces));\r\n        pieces.add(new ma(1, 0, false, pieces));\r\n        pieces.add(new ma(7, 9, true, pieces));\r\n        pieces.add(new ma(7, 0, false, pieces));\r\n        pieces.add(new tuong(2, 9, true, pieces));\r\n        pieces.add(new tuong(2, 0, false, pieces));\r\n        pieces.add(new tuong(6, 9, true, pieces));\r\n        pieces.add(new tuong(6, 0, false, pieces));\r\n        pieces.add(new si(3, 9, true, pieces));\r\n        pieces.add(new si(3, 0, false, pieces));\r\n        pieces.add(new si(5, 9, true, pieces));\r\n        pieces.add(new si(5, 0, false, pieces));\r\n        pieces.add(new phao(1, 7, true, pieces));\r\n        pieces.add(new phao(1, 2, false, pieces));\r\n        pieces.add(new phao(7, 7, true, pieces));\r\n        pieces.add(new phao(7, 2, false, pieces));\r\n\r\n        // Reset lại thời gian và nhãn\r\n        timerLabel.setText(\"Time left: \" + timeLeft);\r\n\r\n        repaint(); // Vẽ lại bàn cờ\r\n    }\r\n    // Hàm xử lý sự kiện đầu hàng\r\n    public void surrender() {\r\n        // Kiểm tra ai là người thua cuộc và thông báo\r\n        String loser = isRedTurn ? \"Đỏ\" : \"Đen\";\r\n        String winner = isRedTurn ? \"Đen\" : \"Đỏ\";\r\n\r\n        // Hiển thị thông báo và kết thúc trò chơi\r\n        JOptionPane.showMessageDialog(this, loser + \" đã đầu hàng. \" + winner + \" thắng!\", \"Game Over\", JOptionPane.INFORMATION_MESSAGE);\r\n        System.exit(0); // Kết thúc trò chơi\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/AI/Board.java b/chess/src/AI/Board.java
--- a/chess/src/AI/Board.java	(revision 694a955fc5ddebba6c85396b41144ab78a12f15f)
+++ b/chess/src/AI/Board.java	(date 1731901565972)
@@ -141,8 +141,13 @@
                                 // Thực hiện di chuyển
                                 selectedPiece.setPosition(newX, newY);
 
-                                String moveData = "MOVE " + selectedPiece.getX() + " " + selectedPiece.getY() + " " + newX + " " + newY;
-                                client.sendMessage(moveData); // Giả sử `client` là đối tượng đang quản lý kết nối với server
+                                if (client != null ) { // Đảm bảo client và out không phải là null
+                                    String moveData = "MOVE " + originalX + " " + originalY + " " + newX + " " + newY;
+                                    System.out.println("Move Data: " + moveData);
+                                    client.sendMessage(moveData);
+                                } else {
+                                    System.err.println("Client not connected or output stream is null.");
+                                }
 
 
                                 // Kiểm tra nếu quân cờ vẫn bị chiếu sau nước đi này
Index: chess/src/network/Client.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package network;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport auth.StartWindow;\r\n\r\nimport model.User;\r\n\r\nimport javax.swing.*;\r\n\r\npublic class Client {\r\n    private static final String SERVER_ADDRESS = \"localhost\";\r\n    private static final int PORT = 12345;\r\n    private StartWindow startWindow;\r\n    private PrintWriter out;\r\n    private BufferedReader in;\r\n    private String roomId;\r\n    private boolean isGameStarted;\r\n    private Runnable onOpponentFound; // Khai báo biến onOpponentFound\r\n    private String username;\r\n    private String password;\r\n    // Phương thức khởi tạo để bắt đầu kết nối\r\n    public void start() {\r\n        try {\r\n            // Tạo kết nối tới server\r\n            Socket socket = new Socket(SERVER_ADDRESS, PORT);\r\n            this.out = new PrintWriter(socket.getOutputStream(), true);\r\n            this.in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n\r\n            // Mở cửa sổ StartWindow khi kết nối thành công\r\n            SwingUtilities.invokeLater(() -> {\r\n                startWindow = new StartWindow(this);\r\n                startWindow.setVisible(true);\r\n            });\r\n\r\n            System.out.println(\"Connected to server at \" + SERVER_ADDRESS + \":\" + PORT);\r\n\r\n            // Tạo luồng nhận nước đi từ đối thủ\r\n            new Thread(() -> {\r\n                String message;\r\n                try {\r\n                    while ((message = in.readLine()) != null) {\r\n                        processMessage(message);\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    try {\r\n                        socket.close();  // Đảm bảo rằng socket chỉ đóng khi hoàn thành công việc\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }).start();\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    // Xử lý tin nhắn từ server\r\n    private void processMessage(String message) {\r\n        System.out.println(\"Received message: \" + message);\r\n\r\n        if (message.startsWith(\"GAME_START\")) {\r\n            roomId = message.split(\" \")[1]; // Lưu ID phòng\r\n            System.out.println(\"Game started in room: \" + roomId);\r\n            SwingUtilities.invokeLater(() -> startWindow.enablePlayButton()); // Kích hoạt nút\r\n        } else if (message.startsWith(\"MOVE\")) {\r\n            updateBoard(message.substring(5)); // Cập nhật bàn cờ với nước đi\r\n        } else if (message.startsWith(\"OPPONENT_FOUND\")) {\r\n            System.out.println(\"Opponent found, notifying client...\");\r\n            SwingUtilities.invokeLater(() -> {\r\n                if (startWindow != null) {\r\n                    startWindow.notifyOpponentFound(); // Thông báo tìm thấy đối thủ\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // Gửi nước đi đến server\r\n    public void sendMove(String move) {\r\n        if (roomId != null && isGameStarted) {\r\n            System.out.println(\"Sending move to server: \" + move);\r\n            out.println(\"MOVE \" + roomId + \" \" + move); // Gửi nước đi cùng ID phòng\r\n            out.flush();\r\n        } else {\r\n            System.out.println(\"Game not started or room ID is null. Cannot send move.\");\r\n        }\r\n    }\r\n\r\n    // Cập nhật bàn cờ khi nhận được thông điệp từ server\r\n\r\n\r\n    // Gửi thông điệp đến server\r\n    public void sendMessage(String message) {\r\n        if (out != null) {\r\n            System.out.println(\"Sending message to server: \" + message);\r\n            out.println(message);\r\n            out.flush();\r\n        } else {\r\n            System.err.println(\"Out stream is null. Make sure the client is connected to the server.\");\r\n        }\r\n    }\r\n\r\n\r\n    // Tìm đối thủ\r\n    public void findOpponent() {\r\n        System.out.println(\"Requesting to find an opponent...\");\r\n        sendMessage(\"FIND_OPPONENT\");\r\n    }\r\n\r\n    // Tạo phòng đấu\r\n    public void createRoom() {\r\n        System.out.println(\"Creating a new room...\");\r\n        sendMessage(\"CREATE_ROOM\");\r\n    }\r\n\r\n    // Đặt callback khi tìm được đối thủ\r\n    public void setOnOpponentFound(Runnable onOpponentFound) {\r\n        this.onOpponentFound = onOpponentFound; // Gán Runnable vào biến\r\n    }\r\n\r\n    // Phương thức main để chạy Client\r\n    public static void main(String[] args) {\r\n\r\n        Client client = new Client();  // Tạo đối tượng Client\r\n        client.start();  // Bắt đầu kết nối và khởi tạo mọi thứ\r\n    }\r\n\r\n    // Thông báo khi tìm được đối thủ\r\n    public void notifyOpponentFound() {\r\n        if (onOpponentFound != null) {\r\n            onOpponentFound.run(); // Thực thi callback khi đối thủ được tìm thấy\r\n        }\r\n    }\r\n    private void updateBoard(String move) {\r\n        System.out.println(\"Updating board with move: \" + move);\r\n        SwingUtilities.invokeLater(() -> {\r\n            startWindow.updateBoard(move); // Cập nhật bàn cờ trong StartWindow\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/network/Client.java b/chess/src/network/Client.java
--- a/chess/src/network/Client.java	(revision 694a955fc5ddebba6c85396b41144ab78a12f15f)
+++ b/chess/src/network/Client.java	(date 1731903031668)
@@ -27,6 +27,12 @@
             this.out = new PrintWriter(socket.getOutputStream(), true);
             this.in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
 
+            // Kiểm tra kết nối đã thành công chưa
+            if (out == null || in == null) {
+                System.err.println("Failed to create input or output streams.");
+                return;
+            }
+
             // Mở cửa sổ StartWindow khi kết nối thành công
             SwingUtilities.invokeLater(() -> {
                 startWindow = new StartWindow(this);
@@ -40,41 +46,59 @@
                 String message;
                 try {
                     while ((message = in.readLine()) != null) {
+                        // Kiểm tra xem socket có bị đóng không trước khi xử lý thông điệp
+                        if (socket.isClosed()) {
+                            System.err.println("Socket is closed. Exiting...");
+                            break;  // Dừng nhận thông điệp nếu socket đã đóng
+                        }
                         processMessage(message);
                     }
                 } catch (IOException e) {
+                    System.err.println("Error while reading from socket: " + e.getMessage());
                     e.printStackTrace();
                 } finally {
                     try {
                         socket.close();  // Đảm bảo rằng socket chỉ đóng khi hoàn thành công việc
                     } catch (IOException e) {
+                        System.err.println("Error while closing socket: " + e.getMessage());
                         e.printStackTrace();
                     }
                 }
             }).start();
 
         } catch (IOException e) {
+            System.err.println("Error while connecting to server: " + e.getMessage());
             e.printStackTrace();
         }
     }
 
-    // Xử lý tin nhắn từ server
     private void processMessage(String message) {
-        System.out.println("Received message: " + message);
+        // Kiểm tra xem socket có bị đóng không trước khi xử lý thông điệp
+        try {
+            if (out != null && !out.checkError()) { // Kiểm tra nếu PrintWriter đã bị lỗi hoặc đóng
+                System.out.println("Received message: " + message);
 
-        if (message.startsWith("GAME_START")) {
-            roomId = message.split(" ")[1]; // Lưu ID phòng
-            System.out.println("Game started in room: " + roomId);
-            SwingUtilities.invokeLater(() -> startWindow.enablePlayButton()); // Kích hoạt nút
-        } else if (message.startsWith("MOVE")) {
-            updateBoard(message.substring(5)); // Cập nhật bàn cờ với nước đi
-        } else if (message.startsWith("OPPONENT_FOUND")) {
-            System.out.println("Opponent found, notifying client...");
-            SwingUtilities.invokeLater(() -> {
-                if (startWindow != null) {
-                    startWindow.notifyOpponentFound(); // Thông báo tìm thấy đối thủ
-                }
-            });
+                if (message.startsWith("GAME_START")) {
+                    roomId = message.split(" ")[1]; // Lưu ID phòng
+                    System.out.println("Game started in room: " + roomId);
+                    SwingUtilities.invokeLater(() -> startWindow.enablePlayButton()); // Kích hoạt nút
+                } else if (message.startsWith("MOVE")) {
+
+                    updateBoard(message.substring(5)); // Cập nhật bàn cờ với nước đi
+                } else if (message.startsWith("OPPONENT_FOUND")) {
+                    System.out.println("Opponent found, notifying client...");
+                    SwingUtilities.invokeLater(() -> {
+                        if (startWindow != null) {
+                            startWindow.notifyOpponentFound(); // Thông báo tìm thấy đối thủ
+                        }
+                    });
+                }
+            } else {
+                System.err.println("Output stream is closed or in error state.");
+            }
+        } catch (Exception e) {
+            System.err.println("Error while processing message: " + e.getMessage());
+            e.printStackTrace();
         }
     }
 
@@ -94,6 +118,7 @@
 
     // Gửi thông điệp đến server
     public void sendMessage(String message) {
+        System.out.println(message);
         if (out != null) {
             System.out.println("Sending message to server: " + message);
             out.println(message);
@@ -102,7 +127,9 @@
             System.err.println("Out stream is null. Make sure the client is connected to the server.");
         }
     }
-
+    public PrintWriter getOut() {
+        return out;
+    }
 
     // Tìm đối thủ
     public void findOpponent() {
Index: .idea/libraries/mysql_connector_j_9_1.xml
===================================================================
diff --git a/.idea/libraries/mysql_connector_j_9_1.xml b/.idea/libraries/mysql_connector_j_9_1.xml
deleted file mode 100644
--- a/.idea/libraries/mysql_connector_j_9_1.xml	(revision 694a955fc5ddebba6c85396b41144ab78a12f15f)
+++ /dev/null	(revision 694a955fc5ddebba6c85396b41144ab78a12f15f)
@@ -1,21 +0,0 @@
-<component name="libraryTable">
-  <library name="mysql-connector-j-9.1">
-    <CLASSES>
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0" />
-    </CLASSES>
-    <JAVADOC />
-    <SOURCES>
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/build/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/demo/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/generated/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/legacy/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/main/core-api/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/main/core-impl/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/main/protocol-impl/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/main/user-api/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/main/user-impl/java" />
-      <root url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0/src/test/java" />
-    </SOURCES>
-    <jarDirectory url="file://$USER_HOME$/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0" recursive="false" />
-  </library>
-</component>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"be8cec2b-98e7-4b28-805e-290db06db14f\" name=\"Changes\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/doancn.iml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/.gitignore\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/chess/src/AI/Board.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/chess/src/AI/Board.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/chess/src/Main.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/chess/src/Main.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/chess/src/auth/StartWindow.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/chess/src/auth/StartWindow.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/chess/src/network/Client.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/chess/src/network/Client.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/chess/src/network/Server.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/chess/src/network/Server.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/AI/Board$1.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/AI/Board$1.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/AI/Board$2.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/AI/Board$2.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/AI/Board$MovePair.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/AI/Board$MovePair.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/AI/Board.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/AI/Board.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/Main.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/Main.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/auth/StartWindow.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/auth/StartWindow.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/network/Client.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/network/Client.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/network/Server.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/network/Server.class\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;binh2401&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/binh2401/doancn.git&quot;,\r\n    &quot;accountId&quot;: &quot;df78a172-c60b-4e92-89a6-55dc890ff87f&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;customColor&quot;: &quot;&quot;,\r\n  &quot;associatedIndex&quot;: 6\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2ozDzWNXl9bHaMiKqZBEuSQABN2\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Application.Client.executor\": \"Run\",\r\n    \"Application.Main.executor\": \"Run\",\r\n    \"Application.Server.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"kotlin-language-version-configured\": \"true\",\r\n    \"last_opened_file_path\": \"C:/Users/PC/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0\",\r\n    \"project.structure.last.edited\": \"Libraries\",\r\n    \"project.structure.proportion\": \"0.0\",\r\n    \"project.structure.side.proportion\": \"0.0\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"Application.Client\">\r\n    <configuration name=\"Client\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"network.Client\" />\r\n      <module name=\"doancn\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"network.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n        <option name=\"com.soywiz.korge.intellij.UpdateResourceBeforeRunTask\" enabled=\"false\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Main\" />\r\n      <module name=\"doancn\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n        <option name=\"com.soywiz.korge.intellij.UpdateResourceBeforeRunTask\" enabled=\"false\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Server\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"network.Server\" />\r\n      <module name=\"doancn\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"network.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n        <option name=\"com.soywiz.korge.intellij.UpdateResourceBeforeRunTask\" enabled=\"false\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.Client\" />\r\n        <item itemvalue=\"Application.Server\" />\r\n        <item itemvalue=\"Application.Main\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"be8cec2b-98e7-4b28-805e-290db06db14f\" name=\"Changes\" comment=\"\" />\r\n      <created>1731863774437</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1731863774437</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 694a955fc5ddebba6c85396b41144ab78a12f15f)
+++ b/.idea/workspace.xml	(date 1731910380545)
@@ -4,22 +4,17 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="be8cec2b-98e7-4b28-805e-290db06db14f" name="Changes" comment="">
+    <list default="true" id="e4279950-1eab-45e4-a1ff-c213701bb7da" name="Changes" comment="">
       <change afterPath="$PROJECT_DIR$/doancn.iml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/.gitignore" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/libraries/mysql_connector_j_9_1.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/chess/src/AI/Board.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/AI/Board.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/chess/src/Main.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/Main.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/chess/src/auth/StartWindow.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/auth/StartWindow.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/chess/src/network/Client.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/network/Client.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/chess/src/network/Server.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/network/Server.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/AI/Board$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/AI/Board$1.class" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/AI/Board$2.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/AI/Board$2.class" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/AI/Board$MovePair.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/AI/Board$MovePair.class" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/AI/Board.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/AI/Board.class" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/Main.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/Main.class" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/auth/StartWindow.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/auth/StartWindow.class" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/network/Client.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/network/Client.class" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/network/Server.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/network/Server.class" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -45,26 +40,21 @@
   &quot;customColor&quot;: &quot;&quot;,
   &quot;associatedIndex&quot;: 6
 }</component>
-  <component name="ProjectId" id="2ozDzWNXl9bHaMiKqZBEuSQABN2" />
+  <component name="ProjectId" id="2p0EnVJAJc5wfrJGnMHcqomizeZ" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Application.Client.executor": "Run",
-    "Application.Main.executor": "Run",
-    "Application.Server.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "SHARE_PROJECT_CONFIGURATION_FILES": "true",
-    "git-widget-placeholder": "main",
-    "kotlin-language-version-configured": "true",
-    "last_opened_file_path": "C:/Users/PC/Downloads/mysql-connector-j-9.1.0/mysql-connector-j-9.1.0",
-    "project.structure.last.edited": "Libraries",
-    "project.structure.proportion": "0.0",
-    "project.structure.side.proportion": "0.0"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Application.Client.executor&quot;: &quot;Run&quot;,
+    &quot;Application.Server.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
+    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;
   }
-}]]></component>
+}</component>
   <component name="RunManager" selected="Application.Client">
     <configuration name="Client" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
       <option name="MAIN_CLASS_NAME" value="network.Client" />
@@ -75,14 +65,6 @@
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <method v="2">
-        <option name="Make" enabled="true" />
-        <option name="com.soywiz.korge.intellij.UpdateResourceBeforeRunTask" enabled="false" />
-      </method>
-    </configuration>
-    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="Main" />
-      <module name="doancn" />
       <method v="2">
         <option name="Make" enabled="true" />
         <option name="com.soywiz.korge.intellij.UpdateResourceBeforeRunTask" enabled="false" />
@@ -106,19 +88,29 @@
       <list>
         <item itemvalue="Application.Client" />
         <item itemvalue="Application.Server" />
-        <item itemvalue="Application.Main" />
       </list>
     </recent_temporary>
   </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
     <task active="true" id="Default" summary="Default task">
-      <changelist id="be8cec2b-98e7-4b28-805e-290db06db14f" name="Changes" comment="" />
-      <created>1731863774437</created>
+      <changelist id="e4279950-1eab-45e4-a1ff-c213701bb7da" name="Changes" comment="" />
+      <created>1731894760852</created>
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
-      <updated>1731863774437</updated>
+      <updated>1731894760852</updated>
     </task>
     <servers />
   </component>
+  <component name="XDebuggerManager">
+    <breakpoint-manager>
+      <breakpoints>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/chess/src/AI/Board.java</url>
+          <line>235</line>
+          <option name="timeStamp" value="1" />
+        </line-breakpoint>
+      </breakpoints>
+    </breakpoint-manager>
+  </component>
 </project>
\ No newline at end of file
Index: doancn.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/doancn.iml b/doancn.iml
new file mode 100644
--- /dev/null	(date 1731894841846)
+++ b/doancn.iml	(date 1731894841846)
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/chess/src" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
