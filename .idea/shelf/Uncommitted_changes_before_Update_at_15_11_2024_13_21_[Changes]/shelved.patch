Index: chess/src/network/Server.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package network;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\n\r\npublic class Server {\r\n    private static final int PORT = 12345;\r\n    private static final Map<String, GameRoom> rooms = new HashMap<>(); // Quản lý các phòng chơi\r\n    private static final Queue<ClientHandler> waitingClients = new LinkedList<>(); // Hàng đợi tìm đối thủ\r\n\r\n    public static void main(String[] args) {\r\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\r\n            System.out.println(\"Server is running...\");\r\n\r\n            while (true) {\r\n                // Chấp nhận kết nối từ client\r\n                Socket clientSocket = serverSocket.accept();\r\n                System.out.println(\"New client connected: \" + clientSocket);\r\n\r\n                // Tạo ClientHandler cho mỗi client kết nối và chạy trong một luồng riêng biệt\r\n                ClientHandler clientHandler = new ClientHandler(clientSocket);\r\n                new Thread(clientHandler).start();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    // Tìm đối thủ và tạo phòng chơi\r\n    public static synchronized void findOpponent(ClientHandler client) {\r\n        System.out.println(\"Searching for opponent for client: \" + client);  // Log khi server bắt đầu tìm đối thủ\r\n\r\n        // Nếu có client khác trong hàng đợi, ghép cặp ngay\r\n        if (!waitingClients.isEmpty()) {\r\n            // Lấy đối thủ từ hàng đợi\r\n            ClientHandler opponent = waitingClients.poll();\r\n            String roomId = UUID.randomUUID().toString(); // Tạo ID phòng duy nhất\r\n            GameRoom room = new GameRoom(roomId, client, opponent);\r\n            rooms.put(roomId, room);\r\n\r\n            // Thông báo cho cả hai client về phòng chơi và bắt đầu trò chơi\r\n            client.setRoom(room);\r\n            opponent.setRoom(room);\r\n            client.sendMessage(\"GAME_START \" + roomId);\r\n            opponent.sendMessage(\"GAME_START \" + roomId);\r\n            System.out.println(\"Game started in room: \" + roomId);  // Log khi phòng được tạo và trò chơi bắt đầu\r\n        } else {\r\n            // Nếu không có đối thủ, thêm vào hàng đợi\r\n            waitingClients.add(client);\r\n            client.sendMessage(\"WAIT_FOR_OPPONENT\");\r\n            System.out.println(\"network.Client added to waiting list: \" + client);\r\n        }\r\n    }\r\n\r\n    // Xử lý nước đi\r\n    public static synchronized void handleMove(String roomId, String move, ClientHandler sender) {\r\n        GameRoom room = rooms.get(roomId);\r\n        if (room != null) {\r\n            // Kiểm tra xem có phải lượt của người chơi không\r\n            if ((sender == room.getPlayer1() && room.isPlayer1Turn()) ||\r\n                    (sender == room.getPlayer2() && !room.isPlayer1Turn())) {\r\n\r\n                // Xử lý nước đi và gửi cho đối thủ\r\n                room.broadcastMove(move, sender);  // Gửi nước đi cho đối thủ\r\n\r\n                // Đổi lượt cho người chơi\r\n                room.switchTurn();\r\n            } else {\r\n                // Gửi thông báo yêu cầu chờ lượt\r\n                sender.sendMessage(\"WAIT_FOR_YOUR_TURN\");\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/network/Server.java b/chess/src/network/Server.java
--- a/chess/src/network/Server.java	(revision 94de07df07120aa9272454314b7b421dd115dcef)
+++ b/chess/src/network/Server.java	(date 1731644353388)
@@ -1,8 +1,13 @@
 package network;
 
-import java.io.*;
-import java.net.*;
-import java.util.*;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+import java.util.UUID;
 
 public class Server {
     private static final int PORT = 12345;
@@ -27,6 +32,13 @@
         }
     }
 
+    public static GameRoom createNewRoom(ClientHandler client) {
+        String roomId = UUID.randomUUID().toString(); // Tạo ID phòng duy nhất
+        GameRoom newRoom = new GameRoom(roomId, client, null);  // Tạo phòng mới với chỉ một player
+        rooms.put(roomId, newRoom);
+        return newRoom;
+    }
+
     // Tìm đối thủ và tạo phòng chơi
     public static synchronized void findOpponent(ClientHandler client) {
         System.out.println("Searching for opponent for client: " + client);  // Log khi server bắt đầu tìm đối thủ
@@ -42,14 +54,15 @@
             // Thông báo cho cả hai client về phòng chơi và bắt đầu trò chơi
             client.setRoom(room);
             opponent.setRoom(room);
-            client.sendMessage("GAME_START " + roomId);
-            opponent.sendMessage("GAME_START " + roomId);
+            client.sendMessage("GAME_START RED " + room.getBoardState());
+            opponent.sendMessage("GAME_START BLACK " + room.getBoardState());
+            room.startGame(); // Bắt đầu trò chơi
             System.out.println("Game started in room: " + roomId);  // Log khi phòng được tạo và trò chơi bắt đầu
         } else {
             // Nếu không có đối thủ, thêm vào hàng đợi
             waitingClients.add(client);
             client.sendMessage("WAIT_FOR_OPPONENT");
-            System.out.println("network.Client added to waiting list: " + client);
+            System.out.println("Client added to waiting list: " + client);
         }
     }
 
@@ -63,12 +76,14 @@
 
                 // Xử lý nước đi và gửi cho đối thủ
                 room.broadcastMove(move, sender);  // Gửi nước đi cho đối thủ
+                System.out.println("Move handled for room: " + roomId + " Move: " + move);
 
                 // Đổi lượt cho người chơi
                 room.switchTurn();
             } else {
                 // Gửi thông báo yêu cầu chờ lượt
                 sender.sendMessage("WAIT_FOR_YOUR_TURN");
+                System.out.println("Client tried to move out of turn: " + sender);
             }
         }
     }
Index: chess/src/network/GameRoom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package network;\r\n\r\npublic class GameRoom {\r\n    private final String id;\r\n    private final ClientHandler player1;\r\n    private final ClientHandler player2;\r\n    private boolean isPlayer1Turn; // Biến theo dõi lượt đi của player1\r\n\r\n    public GameRoom(String id, ClientHandler player1, ClientHandler player2) {\r\n        this.id = id;\r\n        this.player1 = player1;\r\n        this.player2 = player2;\r\n        this.isPlayer1Turn = true; // Player 1 đi trước\r\n    }\r\n\r\n    // Phương thức gửi nước đi cho đối thủ\r\n    public void broadcastMove(String move, ClientHandler sender) {\r\n        // Kiểm tra lượt đi có hợp lệ không\r\n        if ((sender == player1 && isPlayer1Turn) || (sender == player2 && !isPlayer1Turn)) {\r\n            ClientHandler recipient = (sender == player1) ? player2 : player1;\r\n            if (recipient != null) {\r\n                recipient.sendMessage(\"MOVE \" + move); // Gửi nước đi cho đối thủ\r\n                System.out.println(\"Broadcasting move to opponent: \" + move);  // Log việc gửi nước đi\r\n            }\r\n            // Đổi lượt sau khi phát sóng nước đi\r\n            switchTurn();\r\n        } else {\r\n            // Nếu người chơi đi sai lượt\r\n            sender.sendMessage(\"WAIT_FOR_YOUR_TURN\");\r\n        }\r\n    }\r\n\r\n    // Phương thức bắt đầu game và thông báo màu quân\r\n    public void startGame() {\r\n        // Gửi thông báo bắt đầu game và phân chia quân\r\n        player1.sendMessage(\"GAME_START RED\");\r\n        player2.sendMessage(\"GAME_START BLACK\");\r\n    }\r\n\r\n    // Kiểm tra xem có phải lượt của player1 không\r\n    public boolean isPlayer1Turn() {\r\n        return isPlayer1Turn;\r\n    }\r\n\r\n    // Chuyển lượt giữa 2 người chơi\r\n    public void switchTurn() {\r\n        isPlayer1Turn = !isPlayer1Turn; // Đổi lượt cho người chơi\r\n    }\r\n\r\n    // Trả về ID của phòng\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    // Phương thức getter cho player1\r\n    public ClientHandler getPlayer1() {\r\n        return player1;\r\n    }\r\n\r\n    // Phương thức getter cho player2\r\n    public ClientHandler getPlayer2() {\r\n        return player2;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/network/GameRoom.java b/chess/src/network/GameRoom.java
--- a/chess/src/network/GameRoom.java	(revision 94de07df07120aa9272454314b7b421dd115dcef)
+++ b/chess/src/network/GameRoom.java	(date 1731643971899)
@@ -2,26 +2,44 @@
 
 public class GameRoom {
     private final String id;
-    private final ClientHandler player1;
-    private final ClientHandler player2;
+    private  ClientHandler player1;
+    private  ClientHandler player2;
     private boolean isPlayer1Turn; // Biến theo dõi lượt đi của player1
+    private String boardState; // Trạng thái bàn cờ ban đầu
+    private boolean gameOver; // Biến theo dõi tình trạng trò chơi (kết thúc hay chưa)
 
     public GameRoom(String id, ClientHandler player1, ClientHandler player2) {
         this.id = id;
         this.player1 = player1;
         this.player2 = player2;
         this.isPlayer1Turn = true; // Player 1 đi trước
+        this.boardState = initializeBoard(); // Khởi tạo trạng thái bàn cờ ban đầu
+        this.gameOver = false; // Ban đầu trò chơi chưa kết thúc
+    }
+
+    // Phương thức để khởi tạo trạng thái bàn cờ
+    private String initializeBoard() {
+        // Khởi tạo trạng thái bàn cờ mặc định dưới dạng chuỗi (ví dụ: vị trí các quân cờ)
+        return "InitialBoardState"; // Thay bằng trạng thái bàn cờ thật
     }
 
     // Phương thức gửi nước đi cho đối thủ
     public void broadcastMove(String move, ClientHandler sender) {
+        if (gameOver) {
+            sender.sendMessage("GAME_OVER Game has already ended.");  // Nếu trò chơi đã kết thúc, không thể thực hiện nước đi
+            return;
+        }
+
         // Kiểm tra lượt đi có hợp lệ không
         if ((sender == player1 && isPlayer1Turn) || (sender == player2 && !isPlayer1Turn)) {
             ClientHandler recipient = (sender == player1) ? player2 : player1;
             if (recipient != null) {
                 recipient.sendMessage("MOVE " + move); // Gửi nước đi cho đối thủ
                 System.out.println("Broadcasting move to opponent: " + move);  // Log việc gửi nước đi
+                updateBoardState(move); // Cập nhật trạng thái bàn cờ sau mỗi nước đi
             }
+            // Kiểm tra kết thúc trò chơi
+            checkGameStatus();
             // Đổi lượt sau khi phát sóng nước đi
             switchTurn();
         } else {
@@ -30,11 +48,55 @@
         }
     }
 
-    // Phương thức bắt đầu game và thông báo màu quân
+    // Phương thức cập nhật trạng thái bàn cờ
+    private void updateBoardState(String move) {
+        // Cập nhật trạng thái bàn cờ (bạn cần viết logic cụ thể để cập nhật trạng thái bàn cờ)
+        boardState = "UpdatedBoardState";  // Thay đổi trạng thái bàn cờ sau mỗi nước đi
+    }
+
+    // Phương thức kiểm tra tình trạng trò chơi (thắng, thua, hòa)
+    private void checkGameStatus() {
+        // Kiểm tra điều kiện thắng thua hoặc hòa (cần logic cụ thể về game rules)
+        if (isCheckmate(true)) { // Kiểm tra nếu player1 thua (vì player1 là quân đỏ)
+            gameOver = true;
+            player1.sendMessage("GAME_OVER YOU_LOSE");
+            player2.sendMessage("GAME_OVER YOU_WIN");
+            System.out.println("Game over. Player1 loses.");
+        } else if (isCheckmate(false)) { // Kiểm tra nếu player2 thua (vì player2 là quân đen)
+            gameOver = true;
+            player1.sendMessage("GAME_OVER YOU_WIN");
+            player2.sendMessage("GAME_OVER YOU_LOSE");
+            System.out.println("Game over. Player2 loses.");
+        } else if (isDrawCondition()) {
+            gameOver = true;
+            player1.sendMessage("GAME_OVER DRAW");
+            player2.sendMessage("GAME_OVER DRAW");
+            System.out.println("Game over. It's a draw.");
+        }
+    }
+
+    // Phương thức kiểm tra điều kiện hòa (ví dụ: không còn nước đi hợp lệ)
+    private boolean isDrawCondition() {
+        // Kiểm tra điều kiện hòa (tùy thuộc vào luật chơi của bạn)
+        return false; // Giả sử không có điều kiện hòa
+    }
+
+    // Phương thức kiểm tra tình trạng chiếu tướng (thua) cho người chơi
+    private boolean isCheckmate(boolean isRed) {
+        // Kiểm tra điều kiện chiếu tướng cho quân đỏ (isRed = true) hoặc quân đen (isRed = false)
+        return false; // Đây là ví dụ đơn giản, bạn cần logic kiểm tra chiếu tướng tại đây
+    }
+
+    // Phương thức bắt đầu game và gửi trạng thái bàn cờ ban đầu
     public void startGame() {
-        // Gửi thông báo bắt đầu game và phân chia quân
-        player1.sendMessage("GAME_START RED");
-        player2.sendMessage("GAME_START BLACK");
+        if (gameOver) {
+            System.out.println("Game has already ended. Cannot start a new game.");
+            return;
+        }
+
+        // Gửi thông báo bắt đầu game, phân chia quân và gửi trạng thái bàn cờ ban đầu
+        player1.sendMessage("GAME_START RED " + boardState);
+        player2.sendMessage("GAME_START BLACK " + boardState);
     }
 
     // Kiểm tra xem có phải lượt của player1 không
@@ -61,4 +123,33 @@
     public ClientHandler getPlayer2() {
         return player2;
     }
+
+    // Trả về trạng thái bàn cờ
+    public String getBoardState() {
+        return boardState;
+    }
+    public void removePlayer(ClientHandler player) {
+        if (player == player1) {
+            player1.sendMessage("You have been removed from the game room.");
+            player1 = null; // Gán player1 thành null khi người chơi rời khỏi
+        } else if (player == player2) {
+            player2.sendMessage("You have been removed from the game room.");
+            player2 = null; // Gán player2 thành null khi người chơi rời khỏi
+        }
+
+        // Nếu cả hai người chơi đều đã rời, kết thúc trò chơi
+        if (player1 == null && player2 == null) {
+            gameOver = true; // Đặt trò chơi kết thúc nếu không còn người chơi
+            System.out.println("Game over. No players left.");
+        }
+    }
+    public void broadcastMessage(String message) {
+        if (player1 != null) {
+            player1.sendMessage(message);
+        }
+        if (player2 != null) {
+            player2.sendMessage(message);
+        }
+        System.out.println("Broadcasting message to players: " + message); // Log việc gửi thông báo
+    }
 }
Index: chess/src/network/Client.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package network;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport auth.StartWindow;\r\n\r\nimport javax.swing.*;\r\n\r\npublic class Client {\r\n    private static final String SERVER_ADDRESS = \"localhost\";\r\n    private static final int PORT = 12345;\r\n    private StartWindow startWindow;\r\n    private PrintWriter out;\r\n    private Runnable onOpponentFound;\r\n    private String roomId;\r\n\r\n    // Phương thức khởi tạo để bắt đầu kết nối\r\n    public void start() {\r\n        try (Socket socket = new Socket(SERVER_ADDRESS, PORT);\r\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\r\n             BufferedReader console = new BufferedReader(new InputStreamReader(System.in))) {\r\n\r\n            this.out = out;\r\n\r\n            // Mở cửa sổ auth.StartWindow khi kết nối thành công\r\n            SwingUtilities.invokeLater(() -> {\r\n                startWindow = new StartWindow(this);\r\n                startWindow.setVisible(true);\r\n            });\r\n\r\n            // Tạo luồng nhận nước đi từ đối thủ\r\n            new Thread(() -> {\r\n                String message;\r\n                try {\r\n                    while ((message = in.readLine()) != null) {\r\n                        if (message.startsWith(\"GAME_START\")) {\r\n                            roomId = message.split(\" \")[1]; // Lưu ID phòng\r\n                            System.out.println(\"Game started in room: \" + roomId);\r\n                            SwingUtilities.invokeLater(() -> startWindow.enablePlayButton()); // Kích hoạt nút\r\n                        } else if (message.startsWith(\"MOVE\")) {\r\n                            updateBoard(message.substring(5));\r\n                        }\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            // Gửi nước đi từ console\r\n            String userInput;\r\n            while ((userInput = console.readLine()) != null) {\r\n                sendMove(userInput); // Gửi nước đi tới server\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void sendMove(String move) {\r\n        if (roomId != null) {\r\n            out.println(\"MOVE \" + roomId + \" \" + move); // Gửi nước đi cùng ID phòng\r\n            out.flush();\r\n        }\r\n    }\r\n\r\n    private void updateBoard(String move) {\r\n        SwingUtilities.invokeLater(() -> {\r\n            startWindow.updateBoard(move); // Cập nhật bàn cờ trong auth.StartWindow\r\n        });\r\n    }\r\n\r\n    public void sendMessage(String message) {\r\n        if (out != null) {\r\n            System.out.println(\"Sent message to client: \" + message);\r\n            out.println(message);\r\n        } else {\r\n            System.out.println(\"Out stream is null, cannot send message.\");\r\n        }\r\n    }\r\n\r\n    public void findOpponent() {\r\n        sendMessage(\"FIND_OPPONENT\");\r\n    }\r\n\r\n    public void setOnOpponentFound(Runnable onOpponentFound) {\r\n        this.onOpponentFound = onOpponentFound;\r\n    }\r\n\r\n    public void notifyOpponentFound() {\r\n        if (onOpponentFound != null) {\r\n            onOpponentFound.run();\r\n        }\r\n    }\r\n\r\n    // Phương thức main để chạy Client\r\n    public static void main(String[] args) {\r\n        Client client = new Client();  // Tạo đối tượng Client\r\n        client.start();  // Bắt đầu kết nối và khởi tạo mọi thứ\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/network/Client.java b/chess/src/network/Client.java
--- a/chess/src/network/Client.java	(revision 94de07df07120aa9272454314b7b421dd115dcef)
+++ b/chess/src/network/Client.java	(date 1731644374695)
@@ -11,86 +11,115 @@
     private static final int PORT = 12345;
     private StartWindow startWindow;
     private PrintWriter out;
-    private Runnable onOpponentFound;
+    private BufferedReader in;
     private String roomId;
+    private boolean isGameStarted;
+    private Runnable onOpponentFound; // Khai báo biến onOpponentFound
 
     // Phương thức khởi tạo để bắt đầu kết nối
     public void start() {
-        try (Socket socket = new Socket(SERVER_ADDRESS, PORT);
-             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
-             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
-             BufferedReader console = new BufferedReader(new InputStreamReader(System.in))) {
+        try {
+            // Tạo kết nối tới server
+            Socket socket = new Socket(SERVER_ADDRESS, PORT);
+            this.out = new PrintWriter(socket.getOutputStream(), true);
+            this.in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
 
-            this.out = out;
-
-            // Mở cửa sổ auth.StartWindow khi kết nối thành công
+            // Mở cửa sổ StartWindow khi kết nối thành công
             SwingUtilities.invokeLater(() -> {
                 startWindow = new StartWindow(this);
                 startWindow.setVisible(true);
             });
 
+            System.out.println("Connected to server at " + SERVER_ADDRESS + ":" + PORT);
+
             // Tạo luồng nhận nước đi từ đối thủ
             new Thread(() -> {
                 String message;
                 try {
                     while ((message = in.readLine()) != null) {
-                        if (message.startsWith("GAME_START")) {
-                            roomId = message.split(" ")[1]; // Lưu ID phòng
-                            System.out.println("Game started in room: " + roomId);
-                            SwingUtilities.invokeLater(() -> startWindow.enablePlayButton()); // Kích hoạt nút
-                        } else if (message.startsWith("MOVE")) {
-                            updateBoard(message.substring(5));
-                        }
-                    }
-                } catch (IOException e) {
-                    e.printStackTrace();
+                        processMessage(message);
+                    }
+                } catch (IOException e) {
+                    e.printStackTrace();
+                } finally {
+                    try {
+                        socket.close();  // Đảm bảo rằng socket chỉ đóng khi hoàn thành công việc
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }).start();
+
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    // Xử lý tin nhắn từ server
+    private void processMessage(String message) {
+        System.out.println("Received message: " + message);
+
+        if (message.startsWith("GAME_START")) {
+            roomId = message.split(" ")[1]; // Lưu ID phòng
+            System.out.println("Game started in room: " + roomId);
+            SwingUtilities.invokeLater(() -> startWindow.enablePlayButton()); // Kích hoạt nút
+        } else if (message.startsWith("MOVE")) {
+            updateBoard(message.substring(5)); // Cập nhật bàn cờ với nước đi
+        } else if (message.startsWith("OPPONENT_FOUND")) {
+            System.out.println("Opponent found, notifying client...");
+            SwingUtilities.invokeLater(() -> {
+                if (startWindow != null) {
+                    startWindow.notifyOpponentFound(); // Thông báo tìm thấy đối thủ
                 }
-            }).start();
-
-            // Gửi nước đi từ console
-            String userInput;
-            while ((userInput = console.readLine()) != null) {
-                sendMove(userInput); // Gửi nước đi tới server
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
+            });
         }
     }
 
+    // Gửi nước đi đến server
     public void sendMove(String move) {
-        if (roomId != null) {
+        if (roomId != null && isGameStarted) {
+            System.out.println("Sending move to server: " + move);
             out.println("MOVE " + roomId + " " + move); // Gửi nước đi cùng ID phòng
             out.flush();
+        } else {
+            System.out.println("Game not started or room ID is null. Cannot send move.");
         }
     }
 
+    // Cập nhật bàn cờ khi nhận được thông điệp từ server
     private void updateBoard(String move) {
+        System.out.println("Updating board with move: " + move);
         SwingUtilities.invokeLater(() -> {
-            startWindow.updateBoard(move); // Cập nhật bàn cờ trong auth.StartWindow
+            startWindow.updateBoard(move); // Cập nhật bàn cờ trong StartWindow
         });
     }
 
+    // Gửi thông điệp đến server
     public void sendMessage(String message) {
         if (out != null) {
-            System.out.println("Sent message to client: " + message);
+            System.out.println("Sending message to server: " + message);
             out.println(message);
+            out.flush();
         } else {
             System.out.println("Out stream is null, cannot send message.");
         }
     }
 
+    // Tìm đối thủ
     public void findOpponent() {
+        System.out.println("Requesting to find an opponent...");
         sendMessage("FIND_OPPONENT");
     }
 
+    // Tạo phòng đấu
+    public void createRoom() {
+        System.out.println("Creating a new room...");
+        sendMessage("CREATE_ROOM");
+    }
+
+    // Đặt callback khi tìm được đối thủ
     public void setOnOpponentFound(Runnable onOpponentFound) {
-        this.onOpponentFound = onOpponentFound;
-    }
-
-    public void notifyOpponentFound() {
-        if (onOpponentFound != null) {
-            onOpponentFound.run();
-        }
+        this.onOpponentFound = onOpponentFound; // Gán Runnable vào biến
     }
 
     // Phương thức main để chạy Client
@@ -98,4 +127,11 @@
         Client client = new Client();  // Tạo đối tượng Client
         client.start();  // Bắt đầu kết nối và khởi tạo mọi thứ
     }
+
+    // Thông báo khi tìm được đối thủ
+    public void notifyOpponentFound() {
+        if (onOpponentFound != null) {
+            onOpponentFound.run(); // Thực thi callback khi đối thủ được tìm thấy
+        }
+    }
 }
Index: chess/src/network/ClientHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package network;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.Socket;\r\n\r\npublic class ClientHandler implements Runnable {\r\n    private Socket socket;\r\n    private PrintWriter out;\r\n    private BufferedReader in;\r\n    private GameRoom room;\r\n\r\n    public ClientHandler(Socket socket) {\r\n        this.socket = socket;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        try {\r\n            // Khởi tạo các luồng vào ra\r\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n            out = new PrintWriter(socket.getOutputStream(), true);\r\n\r\n            String message;\r\n            while ((message = in.readLine()) != null) {\r\n                System.out.println(\"Received message from client: \" + message);  // Log message nhận từ client\r\n\r\n                // Phân loại thông điệp và xử lý tương ứng\r\n                if (message.equals(\"FIND_OPPONENT\")) {\r\n                    System.out.println(\"Finding opponent for client: \" + socket.getInetAddress());  // Log khi client yêu cầu tìm đối thủ\r\n                    Server.findOpponent(this); // Tìm đối thủ\r\n                } else if (message.startsWith(\"MOVE\")) {\r\n                    System.out.println(\"Move received: \" + message);  // Log nước đi nhận được từ client\r\n                    handleMove(message);  // Xử lý nước đi\r\n                } else {\r\n                    // Nếu thông điệp không hợp lệ, gửi thông báo lỗi\r\n                    sendMessage(\"INVALID_COMMAND\");\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                socket.close();\r\n                System.out.println(\"network.Client disconnected: \" + socket.getInetAddress());  // Log khi client ngắt kết nối\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Phương thức gửi thông điệp cho client\r\n    public void sendMessage(String message) {\r\n        if (out != null) {\r\n            out.println(message);\r\n            System.out.println(\"Sent message to client: \" + message);  // Log thông báo gửi đến client\r\n        }\r\n    }\r\n\r\n    // Gán phòng cho client\r\n    public void setRoom(GameRoom room) {\r\n        this.room = room;\r\n        System.out.println(\"network.Client assigned to room: \" + room.getId());  // Log khi client được gán phòng\r\n    }\r\n\r\n    // Trả về phòng mà client tham gia\r\n    public GameRoom getRoom() {\r\n        return room;\r\n    }\r\n\r\n    // Kiểm tra xem client có phải là player 1 trong phòng không\r\n    public boolean isPlayer1() {\r\n        return this == room.getPlayer1();\r\n    }\r\n\r\n    // Xử lý nước đi từ client\r\n    private void handleMove(String message) {\r\n        if (room != null && room.isPlayer1Turn() == (this == room.getPlayer1())) {\r\n            String move = message.substring(5);  // Lấy nước đi sau từ khóa \"MOVE \"\r\n\r\n            try {\r\n                // Gửi nước đi tới đối thủ và đổi lượt cho người chơi\r\n                room.broadcastMove(move, this);\r\n                room.switchTurn();  // Đổi lượt cho người chơi\r\n                System.out.println(\"Move handled: \" + move);  // Log khi nước đi được xử lý\r\n            } catch (Exception e) {\r\n                e.printStackTrace();  // In lỗi nếu có\r\n            }\r\n        } else {\r\n            // Nếu không phải lượt của client, gửi thông báo lỗi\r\n            sendMessage(\"NOT_YOUR_TURN\");\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/network/ClientHandler.java b/chess/src/network/ClientHandler.java
--- a/chess/src/network/ClientHandler.java	(revision 94de07df07120aa9272454314b7b421dd115dcef)
+++ b/chess/src/network/ClientHandler.java	(date 1731643665402)
@@ -31,9 +31,16 @@
                 if (message.equals("FIND_OPPONENT")) {
                     System.out.println("Finding opponent for client: " + socket.getInetAddress());  // Log khi client yêu cầu tìm đối thủ
                     Server.findOpponent(this); // Tìm đối thủ
+                } else if (message.equals("CREATE_ROOM")) {
+                    System.out.println("Creating room for client: " + socket.getInetAddress());  // Log khi client yêu cầu tạo phòng
+                    createRoom();  // Tạo phòng mới
                 } else if (message.startsWith("MOVE")) {
                     System.out.println("Move received: " + message);  // Log nước đi nhận được từ client
                     handleMove(message);  // Xử lý nước đi
+                } else if (message.equals("EXIT")) {
+                    System.out.println("Client exiting: " + socket.getInetAddress());  // Log khi client thoát
+                    closeConnection();
+                    break;  // Thoát khỏi vòng lặp khi client ngắt kết nối
                 } else {
                     // Nếu thông điệp không hợp lệ, gửi thông báo lỗi
                     sendMessage("INVALID_COMMAND");
@@ -41,13 +48,8 @@
             }
         } catch (IOException e) {
             e.printStackTrace();
-        } finally {
-            try {
-                socket.close();
-                System.out.println("network.Client disconnected: " + socket.getInetAddress());  // Log khi client ngắt kết nối
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
+            // Nếu có lỗi trong quá trình đọc dữ liệu từ client, đóng kết nối
+            closeConnection();
         }
     }
 
@@ -62,7 +64,7 @@
     // Gán phòng cho client
     public void setRoom(GameRoom room) {
         this.room = room;
-        System.out.println("network.Client assigned to room: " + room.getId());  // Log khi client được gán phòng
+        System.out.println("Client assigned to room: " + room.getId());  // Log khi client được gán phòng
     }
 
     // Trả về phòng mà client tham gia
@@ -75,6 +77,18 @@
         return this == room.getPlayer1();
     }
 
+    // Tạo phòng mới cho client
+    private void createRoom() {
+        GameRoom newRoom = Server.createNewRoom(this);  // Tạo một phòng mới và gán cho client
+        setRoom(newRoom);  // Gán phòng mới cho client
+        sendMessage("ROOM_CREATED " + newRoom.getId());  // Thông báo cho client rằng phòng đã được tạo
+
+        System.out.println("Room created with ID: " + newRoom.getId());  // Log thông tin phòng được tạo
+
+        // Đợi đối thủ gia nhập phòng
+        Server.findOpponent(this);  // Tìm đối thủ cho client trong phòng
+    }
+
     // Xử lý nước đi từ client
     private void handleMove(String message) {
         if (room != null && room.isPlayer1Turn() == (this == room.getPlayer1())) {
@@ -90,7 +104,44 @@
             }
         } else {
             // Nếu không phải lượt của client, gửi thông báo lỗi
-            sendMessage("NOT_YOUR_TURN");
+            sendMessage("WAIT_FOR_YOUR_TURN");
         }
     }
+
+    // Gửi thông báo khi tìm được đối thủ và bắt đầu trò chơi
+    public void notifyOpponentFound(ClientHandler opponent) {
+        sendMessage("OPPONENT_FOUND " + opponent.socket.getInetAddress());  // Thông báo đối thủ cho client
+        opponent.sendMessage("OPPONENT_FOUND " + this.socket.getInetAddress());  // Thông báo đối thủ cho client kia
+        startGame();  // Bắt đầu trò chơi
+    }
+
+    // Bắt đầu trò chơi
+    private void startGame() {
+        sendMessage("GAME_START " + room.getId());  // Gửi thông báo bắt đầu trò chơi cho client
+        System.out.println("Game started in room: " + room.getId());  // Log khi trò chơi bắt đầu
+    }
+
+    // Đóng kết nối của client
+    private void closeConnection() {
+        try {
+            // Kiểm tra và đóng phòng khi client thoát
+            if (room != null) {
+                room.removePlayer(this);  // Xóa người chơi khỏi phòng
+            }
+            socket.close();
+            System.out.println("Connection closed for client: " + socket.getInetAddress());  // Log khi kết nối bị đóng
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+
+    // Thông báo khi trò chơi kết thúc
+    public void endGame(String result) {
+        sendMessage("GAME_OVER " + result);  // Gửi thông báo kết thúc trò chơi cho client
+        if (room != null) {
+            room.broadcastMessage("GAME_OVER " + result);  // Gửi thông báo kết thúc trò chơi cho đối thủ
+        }
+        closeConnection();  // Đóng kết nối sau khi kết thúc trò chơi
+    }
 }
Index: chess/src/auth/StartWindow.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package auth;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\n\r\nimport AI.Board;\r\nimport AI.FunctionPanel;\r\nimport network.Client;\r\nimport sounds.BackgroundMusicPlayer;\r\n\r\npublic class StartWindow extends JFrame {\r\n    private JButton startButton;\r\n    private JButton playWithComputerButton;\r\n    private JButton createRoomButton;\r\n    private JButton findTableButton;\r\n    private JButton loginButton; // Nút đăng nhập\r\n    private JButton registerButton; // Nút đăng ký\r\n    private Image backgroundImage;\r\n    private BackgroundMusicPlayer musicPlayer; // Biến cho lớp âm thanh\r\n    private Client client;\r\n    private JFrame frame; // Khai báo frame cho trò chơi AI\r\n\r\n    private boolean isAIEnabled;\r\n    private String difficulty;\r\n\r\n    // Constructor chỉ nhận client và không còn phương thức main\r\n    public StartWindow(Client client) {\r\n        this.client = client;\r\n        initialize();\r\n    }\r\n\r\n    private void initialize() {\r\n        setTitle(\"Chào mừng đến với Cờ Tướng AI\");\r\n        setSize(700, 700);\r\n        setLayout(new BorderLayout());\r\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n\r\n        // Tải hình nền\r\n        try {\r\n            InputStream input = getClass().getResourceAsStream(\"/img/HinhNen/choi-co-tuong-voi-may.jpg\");\r\n            if (input == null) {\r\n                throw new IOException(\"Không tìm thấy hình ảnh: /img/HinhNen/choi-co-tuong-voi-may.jpg\");\r\n            }\r\n            backgroundImage = ImageIO.read(input);\r\n        } catch (IOException e) {\r\n            System.out.println(\"Không thể tải hình ảnh nền\");\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // Khởi tạo âm thanh nền\r\n        musicPlayer = new BackgroundMusicPlayer();\r\n        musicPlayer.playBackgroundMusic(\"/sounds/nhacnen2.wav\"); // Đường dẫn đến âm thanh nền\r\n\r\n        JLabel title = new JLabel(\"Cờ Tướng AI\", JLabel.CENTER);\r\n        title.setFont(new Font(\"Serif\", Font.BOLD, 24));\r\n        add(title, BorderLayout.NORTH);\r\n\r\n        // Khởi tạo các nút với văn bản và hình nền\r\n        startButton = createButtonWithBackground(\"/img/HinhNen/btn3.jpg\", \"play now\");\r\n\r\n        startButton.addActionListener(e -> {\r\n            startButton.setEnabled(false); // Tạm thời vô hiệu hóa nút\r\n            startButton.setText(\"Vui lòng chờ...\"); // Thay đổi văn bản nút\r\n\r\n            // Gửi yêu cầu đến server để tìm đối thủ\r\n            client.findOpponent();\r\n\r\n            // Xử lý khi người chơi khác đã kết nối\r\n            client.setOnOpponentFound(() -> {\r\n                startButton.setText(\"Chơi ngay\"); // Đổi lại văn bản\r\n                startButton.setEnabled(true); // Bật lại nút\r\n                musicPlayer.stopBackgroundMusic(); // Dừng nhạc nền\r\n                setVisible(false); // Ẩn auth.StartWindow\r\n            });\r\n        });\r\n        playWithComputerButton = createButtonWithBackground(\"/img/HinhNen/btn3.jpg\", \"Chơi với máy\");\r\n        playWithComputerButton.addActionListener(e->{\r\n            musicPlayer.stopBackgroundMusic();\r\n            setVisible(false);\r\n            startGameForAI(); // Gọi phương thức startGameForAI khi người chơi chọn \"Chơi với máy\"\r\n        });\r\n\r\n        createRoomButton = createButtonWithBackground(\"/img/HinhNen/btn3.jpg\", \"Tạo phòng\");\r\n        findTableButton = createButtonWithBackground(\"/img/HinhNen/btn3.jpg\", \"Tìm bàn chơi\");\r\n\r\n        // Đặt kích thước cho các nút\r\n        Dimension buttonSize = new Dimension(200, 50);\r\n        startButton.setPreferredSize(buttonSize);\r\n        playWithComputerButton.setPreferredSize(buttonSize);\r\n        createRoomButton.setPreferredSize(buttonSize);\r\n        findTableButton.setPreferredSize(buttonSize);\r\n\r\n        // Tạo panel chứa các nút và đặt chúng vào giữa cửa sổ\r\n        JPanel buttonPanel = new JPanel();\r\n        buttonPanel.setLayout(new GridBagLayout());\r\n        GridBagConstraints gbc = new GridBagConstraints();\r\n        gbc.gridx = 0;\r\n        gbc.gridy = GridBagConstraints.RELATIVE;\r\n        gbc.insets = new Insets(10, 0, 10, 0); // Khoảng cách giữa các nút\r\n\r\n        buttonPanel.add(startButton, gbc);\r\n        buttonPanel.add(playWithComputerButton, gbc);\r\n        buttonPanel.add(createRoomButton, gbc);\r\n        buttonPanel.add(findTableButton, gbc);\r\n\r\n        add(buttonPanel, BorderLayout.CENTER);\r\n\r\n        // Tạo panel cho các nút đăng nhập và đăng ký\r\n        JPanel authPanel = new JPanel();\r\n        authPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); // Bố trí ở bên trái\r\n        loginButton = new JButton(\"Đăng nhập\");\r\n        registerButton = new JButton(\"Đăng ký\");\r\n\r\n        // Đặt kích thước cho các nút đăng nhập và đăng ký\r\n        loginButton.setPreferredSize(new Dimension(100, 30));\r\n        registerButton.setPreferredSize(new Dimension(100, 30));\r\n        // Thêm các hành động cho nút đăng nhập\r\n        loginButton.addActionListener(e -> {\r\n            // Mở cửa sổ đăng nhập\r\n            new auth.LoginWindow().setVisible(true);\r\n        });\r\n\r\n        // Tương tự cho nút đăng ký\r\n        registerButton.addActionListener(e -> {\r\n            // Mở cửa sổ đăng ký\r\n            new auth.RegisterWindow().setVisible(true);\r\n        });\r\n\r\n        // Thêm nút vào panel\r\n        authPanel.add(loginButton);\r\n        authPanel.add(registerButton);\r\n\r\n        // Đặt panel đăng nhập và đăng ký vào góc dưới bên trái\r\n        add(authPanel, BorderLayout.SOUTH);\r\n\r\n        setLocationRelativeTo(null);\r\n        setVisible(true);\r\n    }\r\n\r\n    // Phương thức tạo nút với hình nền và văn bản\r\n    private JButton createButtonWithBackground(String imagePath, String text) {\r\n        JButton button = new JButton();\r\n        try {\r\n            InputStream input = getClass().getResourceAsStream(imagePath);\r\n            if (input == null) {\r\n                throw new IOException(\"Không tìm thấy hình ảnh: \" + imagePath);\r\n            }\r\n            ImageIcon icon = new ImageIcon(ImageIO.read(input));\r\n\r\n            // Điều chỉnh kích thước hình ảnh theo kích thước nút\r\n            Image scaledImage = icon.getImage().getScaledInstance(200, 50, Image.SCALE_SMOOTH);\r\n            button.setIcon(new ImageIcon(scaledImage));\r\n\r\n            // Thiết lập văn bản cho nút\r\n            button.setText(text);\r\n            button.setHorizontalTextPosition(SwingConstants.CENTER); // Đặt vị trí văn bản\r\n            button.setVerticalTextPosition(SwingConstants.CENTER);   // Đặt vị trí văn bản\r\n            button.setFont(new Font(\"Arial\", Font.BOLD, 16)); // Cỡ chữ\r\n            button.setForeground(Color.WHITE); // Màu chữ\r\n\r\n            button.setPreferredSize(new Dimension(200, 50));\r\n            button.setContentAreaFilled(false); // Không tô màu nền cho nút\r\n            button.setBorderPainted(false); // Không vẽ viền cho nút\r\n            button.setFocusPainted(false); // Không tô viền khi chọn nút\r\n        } catch (Exception e) {\r\n            System.out.println(\"Không thể tải hình ảnh: \" + imagePath);\r\n            e.printStackTrace();\r\n        }\r\n        return button;\r\n    }\r\n\r\n    // Phương thức vẽ hình nền\r\n    @Override\r\n    public void paint(Graphics g) {\r\n        super.paint(g);\r\n        if (backgroundImage != null) {\r\n            g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), this);\r\n        }\r\n    }\r\n\r\n    public void enablePlayButton() {\r\n        startButton.setEnabled(true); // Bật nút khi nhận được tín hiệu \"READY_TO_START\"\r\n    }\r\n\r\n    public void updateBoard(String move) {\r\n        System.out.println(\"Cập nhật bàn cờ với nước đi: \" + move);\r\n        // Cập nhật GUI hoặc bàn cờ ở đây\r\n    }\r\n\r\n    // Phương thức bắt đầu trò chơi với AI\r\n    public void startGameForAI() {\r\n        if (frame == null) {\r\n            frame = new JFrame(\"Đồ án cờ tướng AI\"); // Khởi tạo frame nếu chưa có\r\n            frame.setLayout(new BorderLayout());\r\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        } else {\r\n            frame.getContentPane().removeAll(); // Xóa cửa sổ hiện tại\r\n        }\r\n\r\n        // Hiển thị hộp thoại chọn độ khó AI\r\n        String[] options = {\"Dễ\", \"Trung bình\", \"Khó\"};\r\n        int choice = JOptionPane.showOptionDialog(null,\r\n                \"Chọn độ khó của AI:\",\r\n                \"Chọn độ khó\",\r\n                JOptionPane.DEFAULT_OPTION,\r\n                JOptionPane.INFORMATION_MESSAGE,\r\n                null,\r\n                options,\r\n                options[1]); // Mặc định chọn Trung bình\r\n\r\n        String difficulty = \"medium\"; // Mặc định là \"Trung bình\"\r\n        switch (choice) {\r\n            case 0:\r\n                difficulty = \"easy\";\r\n                break;\r\n            case 1:\r\n                difficulty = \"medium\";\r\n                break;\r\n            case 2:\r\n                difficulty = \"hard\";\r\n                break;\r\n        }\r\n        Board board = new Board(true, difficulty); // Truyền thông tin độ khó vào Board\r\n        // Tạo một FunctionPanel mới cho trò chơi AI\r\n        FunctionPanel functionPanel = new FunctionPanel(board); // Tạo FunctionPanel\r\n        frame.add(board, BorderLayout.CENTER); // Bàn cờ ở giữa\r\n        frame.add(functionPanel, BorderLayout.EAST); // Bảng chức năng ở bên phải\r\n\r\n        // Sử dụng pack() để tự động điều chỉnh kích thước cửa sổ phù hợp\r\n        frame.pack();\r\n        frame.setVisible(true); // Hiện cửa sổ chính\r\n        // Thiết lập JFrame hiển thị toàn màn hình\r\n        frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\r\n        frame.setVisible(true);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/chess/src/auth/StartWindow.java b/chess/src/auth/StartWindow.java
--- a/chess/src/auth/StartWindow.java	(revision 94de07df07120aa9272454314b7b421dd115dcef)
+++ b/chess/src/auth/StartWindow.java	(date 1731642884625)
@@ -236,5 +236,34 @@
         frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
         frame.setVisible(true);
     }
+    public void notifyOpponentFound() {
+        // Cập nhật giao diện khi tìm thấy đối thủ
+        JOptionPane.showMessageDialog(this, "Đối thủ đã được tìm thấy!", "Thông báo", JOptionPane.INFORMATION_MESSAGE);
+
+        // Kích hoạt lại nút và thay đổi tên nút
+        startButton.setEnabled(true);
+        startButton.setText("Chơi ngay");
+
+        // Bắt đầu trò chơi
+        startGame();
+    }
+    public void startGame() {
+        System.out.println("Bắt đầu trò chơi!");
+
+        // Logic bắt đầu trò chơi
+        // Ví dụ: chuyển sang cửa sổ chơi hoặc khởi tạo một game room mới nếu chơi đối kháng với người khác
+
+        // Bạn có thể thêm mã để chuyển sang giao diện chính của trò chơi
+        // Giả sử bạn chuyển sang JFrame cho phần chơi với đối thủ
+        // Đây chỉ là ví dụ minh họa
+        JFrame gameFrame = new JFrame("Trò chơi Cờ Tướng");
+        gameFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        gameFrame.setSize(800, 600);
+        gameFrame.setVisible(true);
+
+        // Ẩn cửa sổ start
+        this.setVisible(false);
+    }
+
 
 }
Index: doancn.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/doancn.iml b/doancn.iml
new file mode 100644
--- /dev/null	(date 1731640510136)
+++ b/doancn.iml	(date 1731640510136)
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/chess/src" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"d11cb82b-865c-445f-844c-85ca75e22e3a\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/libraries/mysql_connector_j_9_1.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/Client.class\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/FunctionPanel$1.class\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/FunctionPanel$2.class\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/FunctionPanel$3.class\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/FunctionPanel.class\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/Main.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/Main.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/StartWindow.class\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/network/ClientHandler.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/network/ClientHandler.class\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/out/production/doancn/network/Server.class\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/out/production/doancn/network/Server.class\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\"><![CDATA[{\r\n  \"lastFilter\": {\r\n    \"state\": \"OPEN\",\r\n    \"assignee\": \"meowwon\"\r\n  }\r\n}]]></component>\r\n  <component name=\"GithubPullRequestsUISettings\"><![CDATA[{\r\n  \"selectedUrlAndAccountId\": {\r\n    \"url\": \"https://github.com/binh2401/doancn.git\",\r\n    \"accountId\": \"8187ac63-3546-445a-828c-4e61cbce94a8\"\r\n  }\r\n}]]></component>\r\n  <component name=\"ProjectColorInfo\"><![CDATA[{\r\n  \"customColor\": \"\",\r\n  \"associatedIndex\": 6\r\n}]]></component>\r\n  <component name=\"ProjectId\" id=\"2ooTv25pZzzI9o2avb8ylfzf6dp\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Application.Client.executor\": \"Run\",\r\n    \"Application.Main.executor\": \"Run\",\r\n    \"Application.Server.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"com.google.cloudcode.ide_session_index\": \"20241114_0000\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"kotlin-language-version-configured\": \"true\",\r\n    \"project.structure.last.edited\": \"Modules\",\r\n    \"project.structure.proportion\": \"0.0\",\r\n    \"project.structure.side.proportion\": \"0.0\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"Client\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"network.Client\" />\r\n      <module name=\"doancn\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"network.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Server\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"network.Server\" />\r\n      <module name=\"doancn\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"network.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.Client\" />\r\n        <item itemvalue=\"Application.Server\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"d11cb82b-865c-445f-844c-85ca75e22e3a\" name=\"Changes\" comment=\"\" />\r\n      <created>1731535157612</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1731535157612</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 94de07df07120aa9272454314b7b421dd115dcef)
+++ b/.idea/workspace.xml	(date 1731644392820)
@@ -1,16 +1,21 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
   <component name="ChangeListManager">
-    <list default="true" id="d11cb82b-865c-445f-844c-85ca75e22e3a" name="Changes" comment="">
-      <change beforePath="$PROJECT_DIR$/.idea/libraries/mysql_connector_j_9_1.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/Client.class" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/FunctionPanel$1.class" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/FunctionPanel$2.class" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/FunctionPanel$3.class" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/FunctionPanel.class" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/Main.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/Main.class" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/out/production/doancn/StartWindow.class" beforeDir="false" />
+    <list default="true" id="b28ebd2d-25e7-4119-86e2-170ab7965780" name="Changes" comment="">
+      <change afterPath="$PROJECT_DIR$/doancn.iml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/chess/src/auth/StartWindow.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/auth/StartWindow.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/chess/src/network/Client.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/network/Client.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/chess/src/network/ClientHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/network/ClientHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/chess/src/network/GameRoom.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/network/GameRoom.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/chess/src/network/Server.java" beforeDir="false" afterPath="$PROJECT_DIR$/chess/src/network/Server.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/doancn/auth/StartWindow.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/auth/StartWindow.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/doancn/network/Client.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/network/Client.class" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/network/ClientHandler.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/network/ClientHandler.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/doancn/network/GameRoom.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/network/GameRoom.class" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/out/production/doancn/network/Server.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/doancn/network/Server.class" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -37,35 +42,34 @@
   "customColor": "",
   "associatedIndex": 6
 }]]></component>
-  <component name="ProjectId" id="2ooTv25pZzzI9o2avb8ylfzf6dp" />
+  <component name="ProjectId" id="2orvPzw8UDiy5ynOyjxAj9M8Rfg" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
   <component name="PropertiesComponent"><![CDATA[{
   "keyToString": {
-    "Application.Client.executor": "Run",
-    "Application.Main.executor": "Run",
+    "Application.1.executor": "Run",
+    "Application.2.executor": "Run",
     "Application.Server.executor": "Run",
     "RunOnceActivity.ShowReadmeOnStart": "true",
-    "com.google.cloudcode.ide_session_index": "20241114_0000",
+    "SHARE_PROJECT_CONFIGURATION_FILES": "true",
+    "com.google.cloudcode.ide_session_index": "20241115_0000",
     "git-widget-placeholder": "main",
-    "kotlin-language-version-configured": "true",
-    "project.structure.last.edited": "Modules",
-    "project.structure.proportion": "0.0",
-    "project.structure.side.proportion": "0.0"
+    "kotlin-language-version-configured": "true"
   }
 }]]></component>
-  <component name="RunManager">
-    <configuration name="Client" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
+  <component name="RunManager" selected="Application.1">
+    <configuration name="1" type="Application" factoryName="Application">
       <option name="MAIN_CLASS_NAME" value="network.Client" />
       <module name="doancn" />
-      <extension name="coverage">
-        <pattern>
-          <option name="PATTERN" value="network.*" />
-          <option name="ENABLED" value="true" />
-        </pattern>
-      </extension>
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="2" type="Application" factoryName="Application">
+      <option name="MAIN_CLASS_NAME" value="network.Client" />
+      <module name="doancn" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
@@ -83,9 +87,13 @@
         <option name="Make" enabled="true" />
       </method>
     </configuration>
+    <list>
+      <item itemvalue="Application.1" />
+      <item itemvalue="Application.2" />
+      <item itemvalue="Application.Server" />
+    </list>
     <recent_temporary>
       <list>
-        <item itemvalue="Application.Client" />
         <item itemvalue="Application.Server" />
       </list>
     </recent_temporary>
@@ -93,11 +101,11 @@
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
     <task active="true" id="Default" summary="Default task">
-      <changelist id="d11cb82b-865c-445f-844c-85ca75e22e3a" name="Changes" comment="" />
-      <created>1731535157612</created>
+      <changelist id="b28ebd2d-25e7-4119-86e2-170ab7965780" name="Changes" comment="" />
+      <created>1731640491099</created>
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
-      <updated>1731535157612</updated>
+      <updated>1731640491099</updated>
     </task>
     <servers />
   </component>
